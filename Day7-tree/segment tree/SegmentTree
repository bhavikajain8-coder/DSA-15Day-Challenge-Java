package com.Segmenttrees;


public final class SegmentTree {

    public Node getRoot() {
        return root;
    }

    public void setRoot(Node root) {
        this.root = root;
    }

    private static class Node {
    int data;
    int startInterval;
    int endInterval;
    Node left;
    Node right;

    public Node (int startInterval, int endInterval) {
      this.startInterval = startInterval;
      this.endInterval = endInterval;
    }
  }

  private Node root;

  public SegmentTree(int... arr) {
    // create a tree using this array
    root = constructTree(arr, 0, arr.length - 1);
  }

  private Node constructTree(int[] arr, int start, int end) {
    if(start == end) {
      // leaf node
      Node leaf = new Node(start, end);
      leaf.data = arr[start];
      return leaf;
    }

    // create new node with index you are at
    Node node = new Node(start, end);

    int mid = (start + end) / 2;

    node.left = constructTree(arr, start, mid);
    node.right = constructTree(arr, mid + 1, end);

    node.data = node.left.data + node.right.data;
    return node;
  }

  public void display() {
    display(root);
  }
  private void display(Node node) {
      while (true) {
          String str = "";

          if (node.left != null) {
              str = str + "Interval=[" + node.left.startInterval + "-" + node.left.endInterval + "] and data: " + node.left.data + " => ";
          } else {
              str += "No left child";
          }

          // for current node
          str = str + "Interval=[" + node.startInterval + "-" + node.endInterval + "] and data: " + node.data + " <= ";

          if (node.right != null) {
              str = str + "Interval=[" + node.right.startInterval + "-" + node.right.endInterval + "] and data: " + node.right.data;
          } else {
              str += "No right child";
          }

          System.out.println(str + '\n');

          // call recursion
          if (node.left != null) {
              display(node.left);
          }

          if (node.right != null) {
              node = node.right;
              continue;
          }
          return;
      }
  }

  // query
  public int query(int qsi, int qei) {
    return query(root, qsi, qei);
  }
  private int query(Node node, int qsi, int qei) {
    if(node.startInterval >= qsi && node.endInterval <= qei) {
      // node is completely lying inside query
      return node.data;
    } else if (node.startInterval > qei || node.endInterval < qsi) {
      // completely outside
      return 0;
    } else {
      return query(node.left, qsi, qei) + query(node.right, qsi, qei);
    }
  }

  // update
  public void update(int index, int value) {
    root.data = update(root, index, value);
  }
  private int update(Node node, int index, int value) {
    if (index >= node.startInterval&& index <= node.endInterval){
      if(index == node.startInterval && index == node.endInterval) {
        node.data = value;
      } else {
        int leftAns = update(node.left, index, value);
        int rightAns = update(node.right, index, value);
        node.data = leftAns + rightAns;
      }
        return node.data;
    }
    return node.data;
  }

}
